<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rubik's Cube Solver</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            user-select: none;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group h3 {
            color: white;
            margin: 0 0 10px 0;
            font-size: 14px;
            font-weight: bold;
        }
        
        .button-row {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        button {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.2s ease;
            min-width: 40px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }

        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        
        #reset-btn, #scramble-btn, #solve-btn {
            background: linear-gradient(135deg, #48cae4, #0077b6);
            margin-top: 5px;
            width: 100%;
        }
        
        #reset-btn:hover, #scramble-btn:hover, #solve-btn:hover {
            box-shadow: 0 5px 15px rgba(72, 202, 228, 0.4);
        }
        
        #scramble-btn {
            background: linear-gradient(135deg, #f72585, #b5179e);
        }
        
        #scramble-btn:hover {
            box-shadow: 0 5-px 15px rgba(247, 37, 133, 0.4);
        }

        #solve-btn {
            background: linear-gradient(135deg, #56ab2f, #a8e063);
        }

        #solve-btn:hover {
            box-shadow: 0 5px 15px rgba(86, 171, 47, 0.4);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Loading 3D Rubik's Cube...</div>
        <div id="canvas-container"></div>
        
        <div id="controls" style="display: none;">
            <div class="control-group">
                <h3>CUBE ROTATION</h3>
                <div class="button-row">
                    <button onclick="rotateCube('x', 1)">X+</button>
                    <button onclick="rotateCube('x', -1)">X-</button>
                </div>
                <div class="button-row">
                    <button onclick="rotateCube('y', 1)">Y+</button>
                    <button onclick="rotateCube('y', -1)">Y-</button>
                </div>
                <div class="button-row">
                    <button onclick="rotateCube('z', 1)">Z+</button>
                    <button onclick="rotateCube('z', -1)">Z-</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3>FACE ROTATIONS</h3>
                <div class="button-row">
                    <button onclick="handleFaceButtonClick('F')">F</button>
                    <button onclick="handleFaceButtonClick('B')">B</button>
                    <button onclick="handleFaceButtonClick('R')">R</button>
                </div>
                <div class="button-row">
                    <button onclick="handleFaceButtonClick('L')">L</button>
                    <button onclick="handleFaceButtonClick('U')">U</button>
                    <button onclick="handleFaceButtonClick('D')">D</button>
                </div>
            </div>
            
            <button id="reset-btn" onclick="resetCube()">RESET CUBE</button>
            <button id="scramble-btn" onclick="scrambleCube()">SCRAMBLE</button>
            <button id="solve-btn" onclick="solveCube()">SOLVE CUBE</button>

        </div>

        <div id="info" style="display: none;">
            <strong>3D Rubik's Cube Solver</strong><br>
            Use the controls to rotate the cube or individual faces.<br>
            <strong>F, B, R, L, U, D:</strong> Standard clockwise face rotations.<br>
            <strong>SCRAMBLE:</strong> Randomize the cube.<br>
            <strong>SOLVE:</strong> Animate the solution for a scrambled cube.
        </div>
        <div id="status" style="display: none;">Status: Idle</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        let scene, camera, renderer, cubeGroup;
        let cubelets = [];
        let isAnimating = false;
        let statusEl;
        
        // --- CUBE CONSTANTS ---
        const colors = {
            front: 0x00ff00,   // Green
            back: 0x0000ff,    // Blue
            right: 0xff0000,   // Red
            left: 0xff6600,    // Orange
            up: 0xffffff,      // White
            down: 0xffff00     // Yellow
        };
        const faces = {
            F: 'front', B: 'back', R: 'right', L: 'left', U: 'up', D: 'down'
        };
        const rotationData = {
            front: { axis: 'z', angle: -Math.PI / 2 },
            back:  { axis: 'z', angle:  Math.PI / 2 },
            right: { axis: 'x', angle:  Math.PI / 2 },
            left:  { axis: 'x', angle: -Math.PI / 2 },
            up:    { axis: 'y', angle:  Math.PI / 2 },
            down:  { axis: 'y', angle: -Math.PI / 2 }
        };
        const colorMap = {
            [colors.up]: 'U', [colors.down]: 'D', 
            [colors.front]: 'F', [colors.back]: 'B',
            [colors.left]: 'L', [colors.right]: 'R',
            0x1a1a1a: 'X' // Non-visible face
        };

        // --- INITIALIZATION ---
        function loadThreeJS() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                script.onload = () => (typeof THREE !== 'undefined' ? resolve() : reject(new Error('Three.js failed to load')));
                script.onerror = () => reject(new Error('Failed to load Three.js from CDN'));
                document.head.appendChild(script);
            });
        }
        
        function updateStatus(text) {
            if (statusEl) statusEl.textContent = text;
        }

        async function initApp() {
            try {
                document.getElementById('loading').textContent = 'Loading Three.js library...';
                await loadThreeJS();
                document.getElementById('loading').textContent = 'Initializing 3D scene...';
                init();
                document.getElementById('controls').style.display = 'block';
                document.getElementById('info').style.display = 'block';
                statusEl = document.getElementById('status');
                statusEl.style.display = 'block';
                updateStatus('Ready');
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('Failed to initialize app:', error);
                document.getElementById('loading').textContent = `Error: ${error.message}. Please refresh.`;
            }
        }
        
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            createCube();
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
            animate();
        }
        
        function createCube() {
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            cubelets = [];
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        if (x === 0 && y === 0 && z === 0) continue;
                        createCubelet(x, y, z);
                    }
                }
            }
        }
        
        function createCubelet(x, y, z) {
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            const faceColors = {
                right:  x === 1 ? colors.right : 0x1a1a1a,
                left:   x === -1 ? colors.left : 0x1a1a1a,
                up:     y === 1 ? colors.up : 0x1a1a1a,
                down:   y === -1 ? colors.down : 0x1a1a1a,
                front:  z === 1 ? colors.front : 0x1a1a1a,
                back:   z === -1 ? colors.back : 0x1a1a1a
            };
            const materials = [
                new THREE.MeshLambertMaterial({ color: faceColors.right }),
                new THREE.MeshLambertMaterial({ color: faceColors.left }),
                new THREE.MeshLambertMaterial({ color: faceColors.up }),
                new THREE.MeshLambertMaterial({ color: faceColors.down }),
                new THREE.MeshLambertMaterial({ color: faceColors.front }),
                new THREE.MeshLambertMaterial({ color: faceColors.back })
            ];
            const cubelet = new THREE.Mesh(geometry, materials);
            cubelet.position.set(x, y, z);
            cubelet.userData = { 
                logicalPosition: new THREE.Vector3(x, y, z),
                faceColors: faceColors
            };
            cubeGroup.add(cubelet);
            cubelets.push(cubelet);
        }

        // --- CORE ROTATION LOGIC ---

        function rotateCube(axis, direction) {
            if (isAnimating) return;

            isAnimating = true;
            const startRotation = cubeGroup.rotation[axis];
            const targetRotation = startRotation + direction * Math.PI / 2;
            const duration = 400;
            const startTime = Date.now();

            function animateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 0.5 - 0.5 * Math.cos(progress * Math.PI);

                cubeGroup.rotation[axis] = startRotation + (targetRotation - startRotation) * eased;

                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                } else {
                    cubeGroup.rotation[axis] = targetRotation; // Snap to final angle
                    isAnimating = false;
                }
            }
            animateRotation();
        }

        async function handleFaceButtonClick(move) {
            if (isAnimating) return;
            await performMove(move);
        }
        
        async function performMove(move) {
            const faceName = faces[move.charAt(0)];
            const isPrime = move.includes("'");
            const isDouble = move.includes("2");
            const turns = isDouble ? 2 : (isPrime ? 3 : 1);
            
            for (let i = 0; i < turns; i++) {
                await rotateFace(faceName, 300);
            }
        }
        
        function rotateFace(face, duration = 300) {
            return new Promise(resolve => {
                const move = rotationData[face];
                let faceGroup = new THREE.Group();
                let faceCubelets = [];

                cubelets.forEach(cubelet => {
                    const pos = cubelet.userData.logicalPosition;
                    let shouldRotate = false;
                    switch(face) {
                        case 'front': shouldRotate = pos.z > 0.5; break;
                        case 'back':  shouldRotate = pos.z < -0.5; break;
                        case 'right': shouldRotate = pos.x > 0.5; break;
                        case 'left':  shouldRotate = pos.x < -0.5; break;
                        case 'up':    shouldRotate = pos.y > 0.5; break;
                        case 'down':  shouldRotate = pos.y < -0.5; break;
                    }
                    if (shouldRotate) faceCubelets.push(cubelet);
                });

                scene.add(faceGroup);
                faceCubelets.forEach(c => cubeGroup.attach(c));
                faceCubelets.forEach(c => faceGroup.attach(c));
                
                const startTime = Date.now();
                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                    faceGroup.rotation[move.axis] = move.angle * eased;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        faceGroup.updateMatrixWorld();
                        faceCubelets.forEach(c => {
                            cubeGroup.attach(c);
                            updateCubeletLogicalState(c, face);
                        });
                        scene.remove(faceGroup);
                        resolve();
                    }
                }
                animate();
            });
        }
        
        function updateCubeletLogicalState(cubelet, face) {
            const pos = cubelet.userData.logicalPosition;
            let newPos;
            switch(face) {
                case 'up':    newPos = { x: pos.z, y: pos.y, z: -pos.x }; break;
                case 'down':  newPos = { x: -pos.z, y: pos.y, z: pos.x }; break;
                case 'right': newPos = { x: pos.x, y: -pos.z, z: pos.y }; break;
                case 'left':  newPos = { x: pos.x, y: pos.z, z: -pos.y }; break;
                case 'front': newPos = { x: pos.y, y: -pos.x, z: pos.z }; break;
                case 'back':  newPos = { x: -pos.y, y: pos.x, z: pos.z }; break;
            }
            cubelet.userData.logicalPosition.set(Math.round(newPos.x), Math.round(newPos.y), Math.round(newPos.z));

            const c = cubelet.userData.faceColors;
            let n = { ...c };
            switch(face) {
                case 'up':    n = { ...c, front: c.left, left: c.back, back: c.right, right: c.front }; break;
                case 'down':  n = { ...c, front: c.right, right: c.back, back: c.left, left: c.front }; break;
                case 'right': n = { ...c, up: c.back, back: c.down, down: c.front, front: c.up }; break;
                case 'left':  n = { ...c, up: c.front, front: c.down, down: c.back, back: c.up }; break;
                case 'front': n = { ...c, up: c.right, right: c.down, down: c.left, left: c.up }; break;
                case 'back':  n = { ...c, up: c.left, left: c.down, down: c.right, right: c.up }; break;
            }
            cubelet.userData.faceColors = n;
        }

        // --- CUBE STATE CONVERSION ---
        function getCubeState() {
            const state = {};
            const faceLetter = { up: 'U', down: 'D', front: 'F', back: 'B', left: 'L', right: 'R' };
            cubelets.forEach(cubelet => {
                const pos = cubelet.userData.logicalPosition;
                const stickers = cubelet.userData.faceColors;
                const key = `(${pos.x},${pos.y},${pos.z})`;

                // Visible faces and their color letters
                const visible = Object.keys(stickers)
                  .filter(face => stickers[face] !== 0x1a1a1a);
                const colorsArr = visible.map(face => colorMap[stickers[face]]);
                const stickerMap = {};
                visible.forEach(face => {
                  stickerMap[faceLetter[face]] = colorMap[stickers[face]];
                });

                state[key] = {
                    pos: { x: pos.x, y: pos.y, z: pos.z },
                    colors: colorsArr,
                    stickers: stickerMap // e.g., { U: 'W', F: 'G' } depending on scheme
                };
            });
            return state;
        }

        // --- CUBE SOLVER (BEGINNER'S METHOD) ---
        class CubeSolver {
            constructor(performMoveFn, cubeStateFn, statusCallback) {
                this.performMove = performMoveFn;
                this.getCubeState = cubeStateFn;
                this.updateStatus = statusCallback || (() => {});
                this.solutionMoves = [];
                this.state = {};
            }

            async solve() {
                this.solutionMoves = [];
                this.state = this.getCubeState();

                const phases = [
                    'White Cross',
                    'White Corners',
                    'Middle Layer',
                    'Yellow Cross',
                    'Position Yellow Corners',
                    'Orient Yellow Corners',
                    'Position Yellow Edges'
                ];
                const totalPhases = phases.length;
                let currentPhase = 0;
                const phaseStatus = () => this.updateStatus(`Phase ${currentPhase + 1}/${totalPhases}: ${phases[currentPhase]} (moves: ${this.solutionMoves.length})`);

                phaseStatus();
                
                const centers = {
                    'U': this.state['(0,1,0)'].colors[0],
                    'D': this.state['(0,-1,0)'].colors[0],
                    'F': this.state['(0,0,1)'].colors[0],
                    'B': this.state['(0,0,-1)'].colors[0],
                    'L': this.state['(-1,0,0)'].colors[0],
                    'R': this.state['(1,0,0)'].colors[0],
                };
                const white = centers.U;
                const yellow = centers.D;

                const cubeSolved = () => {
                    // All stickers on a physical face must match that face's center color
                    const stateNow = this.getCubeState();
                    const faceKeys = ['U','D','F','B','L','R'];
                    for (const key of Object.keys(stateNow)) {
                        const p = stateNow[key];
                        if (!p || !p.stickers) continue;
                        for (const f of Object.keys(p.stickers)) {
                            const color = p.stickers[f];
                            if (centers[f] && color !== centers[f]) return false;
                        }
                    }
                    return true;
                };

                // Early exit for already-solved cubes
                if (cubeSolved()) {
                    this.updateStatus('Already solved');
                    return [];
                }
                
                const findPiece = (c1, c2, c3 = null) => {
                    const keys = Object.keys(this.state);
                    for (const key of keys) {
                        const piece = this.state[key];
                        if (!piece || !piece.colors) continue;
                        if (c3) {
                            // Corner: must match exactly 3 stickers
                            if (piece.colors.length !== 3) continue;
                            if (piece.colors.includes(c1) && piece.colors.includes(c2) && piece.colors.includes(c3)) {
                                return piece;
                            }
                        } else {
                            // Edge: must match exactly 2 stickers
                            if (piece.colors.length !== 2) continue;
                            if (piece.colors.includes(c1) && piece.colors.includes(c2)) {
                                return piece;
                            }
                        }
                    }
                    return null;
                };

                const doMoves = async(moves) => {
                    const moveArray = moves.split(' ');
                    for(const move of moveArray) {
                        if(move) {
                            await this.performMove(move);
                            this.solutionMoves.push(move);
                            this.state = this.getCubeState();
                            phaseStatus();
                        }
                    }
                };

                // Phase 1: White Cross
                const whiteEdges = [
                    { x: 0, y: 1, z: 1, sideColor: 'F' }, // UF
                    { x: 1, y: 1, z: 0, sideColor: 'R' }, // UR
                    { x: 0, y: 1, z: -1, sideColor: 'B' },// UB
                    { x: -1, y: 1, z: 0, sideColor: 'L' }  // UL
                ];
                
                const uFaceFromPos = (pos) => {
                    if (pos.z === 1) return 'F';
                    if (pos.z === -1) return 'B';
                    if (pos.x === 1) return 'R';
                    if (pos.x === -1) return 'L';
                    return null;
                };

                for (let i = 0; i < whiteEdges.length; i++) {
                    const target = whiteEdges[i];
                    let piece = findPiece(white, centers[target.sideColor]);
                    let safety = 0;
                    while (piece) {
                        const s = piece.stickers || {};
                        const whiteOn = Object.keys(s).find(k => s[k] === white) || null;
                        // Done for this edge when it's on U with white facing up; alignment handled after all edges are up
                        if (piece.pos.y === 1 && whiteOn === 'U') break;

                        if (++safety > 100) { await doMoves('U'); safety = 0; }

                        // Step 1: Ensure piece is on D with white facing D
                        if (!(piece.pos.y === -1 && whiteOn === 'D')) {
                            if (piece.pos.y === 1 && whiteOn === 'U') {
                                // Align over target on U and keep it there (no S2 here)
                                let turns = 0;
                                while ((piece.pos.x !== target.x || piece.pos.z !== target.z) && turns < 4) {
                                    await doMoves('U');
                                    piece = findPiece(white, centers[target.sideColor]);
                                    turns++;
                                }
                                // Once aligned, next loop iteration will break via the condition
                            } else if (whiteOn && ['F','B','L','R'].includes(whiteOn)) {
                                // Prefer a conjugated twist when targeting the same side to avoid endless spins (e.g., UL case)
                                if (whiteOn === target.sideColor) {
                                    await doMoves('U ' + whiteOn + " U'");
                                } else {
                                    await doMoves(whiteOn);
                                }
                            } else if (piece.pos.y === -1 && whiteOn !== 'D') {
                                await doMoves(target.sideColor + ' D ' + target.sideColor + "'");
                            } else {
                                await doMoves('U');
                            }
                            piece = findPiece(white, centers[target.sideColor]);
                            continue;
                        }

                        // Step 2: On D with white down: align under target and lift with S2
                        let dTurns = 0;
                        while ((piece.pos.x !== target.x || piece.pos.z !== target.z) && dTurns < 4) {
                            await doMoves('D');
                            piece = findPiece(white, centers[target.sideColor]);
                            dTurns++;
                        }
                        await doMoves(target.sideColor + '2');
                        piece = findPiece(white, centers[target.sideColor]);
                    }
                }
                // After all four edges have white on U, align them to their side centers using U turns only
                let alignSafety = 0;
                const allWhiteEdgesAligned = () => {
                    const checkEdge = (sideLetter) => {
                        const p = findPiece(white, centers[sideLetter]);
                        if (!p || p.pos.y !== 1) return false;
                        const uSide = uFaceFromPos(p.pos);
                        return uSide === sideLetter;
                    };
                    return checkEdge('F') && checkEdge('R') && checkEdge('B') && checkEdge('L');
                };
                while (!allWhiteEdgesAligned() && alignSafety++ < 8) {
                    await doMoves('U');
                }

                // Phase 2: White Corners
                currentPhase = 1;
                phaseStatus();
                const whiteCorners = [
                    { x: 1, y: 1, z: 1, sides: ['F', 'R'] }, // UFR
                    { x: -1, y: 1, z: 1, sides: ['F', 'L'] },// UFL
                    { x: -1, y: 1, z: -1, sides: ['B', 'L'] },// UBL
                    { x: 1, y: 1, z: -1, sides: ['B', 'R'] } // UBR
                ];
                
                for(let i=0; i<whiteCorners.length; i++) {
                    const target = whiteCorners[i];
                    let piece = findPiece(white, centers[target.sides[0]], centers[target.sides[1]]);
                    while(piece && !(piece.pos.x === target.x && piece.pos.y === target.y && piece.pos.z === target.z)) {
                        // Position corner above its spot
                        let pos = piece.pos;
                        while(piece && (pos.y === 1 || !(pos.x === target.x && pos.z === target.z))) {
                            await doMoves('D');
                            this.state = this.getCubeState();
                            piece = findPiece(white, centers[target.sides[0]], centers[target.sides[1]]);
                            if(!piece) break;
                            pos = piece.pos;
                        }

                        if(!piece) break;

                        // Insert corner using R U R' U'
                        let counter = 0;
                        while(piece && !(piece.pos.x === target.x && piece.pos.y === target.y && piece.pos.z === target.z && piece.colors.includes(white))) {
                           await doMoves("R U R' U'");
                           this.state = this.getCubeState();
                           piece = findPiece(white, centers[target.sides[0]], centers[target.sides[1]]);
                           counter++;
                           if(counter > 10) break; // Safety break
                        }
                    }
                }

                // Phase 3: Middle Layer
                currentPhase = 2;
                phaseStatus();
                const middleEdges = [
                    { x: 1, y: 0, z: 1, sides: ['F', 'R'] },
                    { x: -1, y: 0, z: 1, sides: ['F', 'L'] },
                    { x: -1, y: 0, z: -1, sides: ['B', 'L'] },
                    { x: 1, y: 0, z: -1, sides: ['B', 'R'] },
                ];

                for(let i=0; i<middleEdges.length; i++) {
                    const target = middleEdges[i];
                    let piece = findPiece(centers[target.sides[0]], centers[target.sides[1]]);

                    while(piece && !(piece.pos.x === target.x && piece.pos.y === target.y && piece.pos.z === target.z)) {
                         // Find a piece not on the bottom layer or already in place
                         let pos = piece.pos;
                         if(pos.y !== -1) {
                             if(pos.x === 1 && pos.z === 1) await doMoves("R U' R' U'");
                             else if (pos.x === -1 && pos.z === 1) await doMoves("L' U L U");
                             else if (pos.x === -1 && pos.z === -1) await doMoves("L' U' L U");
                             else if (pos.x === 1 && pos.z === -1) await doMoves("R U R' U'");
                             this.state = this.getCubeState();
                             piece = findPiece(centers[target.sides[0]], centers[target.sides[1]]);
                             if(!piece) break;
                             pos = piece.pos;
                         }

                         if(!piece) break;

                         // Align the piece with its front face
                         const frontColor = centers[target.sides[0]];
                         let turns = 0;
                         while(piece) {
                             const pieceFrontColor = (Math.abs(pos.x) === 1) ? piece.colors.find(c => c !== centers.D && c !== centers.U && c !== centers.R && c !== centers.L) : piece.colors.find(c => c !== centers.D && c !== centers.U && c !== centers.F && c !== centers.B);
                             if(pieceFrontColor === frontColor || turns > 4) break;
                             await doMoves('D');
                             this.state = this.getCubeState();
                             piece = findPiece(centers[target.sides[0]], centers[target.sides[1]]);
                             if(!piece) break;
                             pos = piece.pos;
                             turns++;
                         }

                         if(!piece) break;

                         // Insert the edge
                         const rightSide = centers[target.sides[1]] === 'R';
                         if(rightSide) {
                             await doMoves("D' R' D R D F D' F'");
                         } else {
                             await doMoves("D L D' L' D' F' D F");
                         }
                         this.state = this.getCubeState();
                         piece = findPiece(centers[target.sides[0]], centers[target.sides[1]]);
                    }
                }

                // Phase 4: Yellow Cross
                currentPhase = 3;
                phaseStatus();
                let isYellowCross = false;
                while(!isYellowCross) {
                    let yellowEdges = 0;
                    const edgeF = findPiece(yellow, centers.F);
                    const edgeB = findPiece(yellow, centers.B);
                    const edgeL = findPiece(yellow, centers.L);
                    const edgeR = findPiece(yellow, centers.R);
                    if(edgeF && edgeF.pos.y === -1) yellowEdges++;
                    if(edgeB && edgeB.pos.y === -1) yellowEdges++;
                    if(edgeL && edgeL.pos.y === -1) yellowEdges++;
                    if(edgeR && edgeR.pos.y === -1) yellowEdges++;
                    if(yellowEdges === 4) { isYellowCross = true; break; }

                    if (edgeF && edgeR && edgeF.pos.y === -1 && edgeR.pos.y === -1) {
                        await doMoves("F R U R' U' F'");
                    } else if ((edgeF && edgeB && edgeF.pos.y === -1 && edgeB.pos.y === -1) ||
                               (edgeR && edgeL && edgeR.pos.y === -1 && edgeL.pos.y === -1)) {
                        await doMoves("F R U R' U' F'");
                        await doMoves("F R U R' U' F'");
                    } else {
                        await doMoves("F R U R' U' F'");
                    }
                }

                // Phase 5: Position Yellow Corners
                currentPhase = 4;
                phaseStatus();
                for(let i=0; i<4; i++) {
                    let countCorrect = 0;
                    const ufr = findPiece(centers.U, centers.F, centers.R);
                    const ufl = findPiece(centers.U, centers.F, centers.L);
                    const ubl = findPiece(centers.U, centers.B, centers.L);
                    const ubr = findPiece(centers.U, centers.B, centers.R);
                    if(ufr && ufr.pos.x === 1 && ufr.pos.z === 1) countCorrect++;
                    if(ufl && ufl.pos.x === -1 && ufl.pos.z === 1) countCorrect++;
                    if(ubl && ubl.pos.x === -1 && ubl.pos.z === -1) countCorrect++;
                    if(ubr && ubr.pos.x === 1 && ubr.pos.z === -1) countCorrect++;

                    if (countCorrect === 4) break;

                    await doMoves("R' F R B' R' F' R B");
                }

                // Phase 6: Orient Yellow Corners
                currentPhase = 5;
                phaseStatus();
                for(let i=0; i<4; i++) {
                    let piece = findPiece(centers.U, centers.F, centers.R);
                    if(piece && piece.colors.includes(yellow)) {
                        await doMoves("U");
                    }
                    const ufl = findPiece(centers.U, centers.F, centers.L);
                    const ubl = findPiece(centers.U, centers.B, centers.L);
                    const ubr = findPiece(centers.U, centers.B, centers.R);
                    if(ufl && ubl && ubr && ufl.colors.includes(yellow) && ubl.colors.includes(yellow) && ubr.colors.includes(yellow)) break;

                    await doMoves("R' D' R D R' D' R D");
                }

                // Phase 7: Position Yellow Edges
                currentPhase = 6;
                phaseStatus();
                let isSolved = false;
                for(let i=0; i<4; i++) {
                    if (isSolved) break;
                    let count = 0;
                    const edgeF2 = findPiece(yellow, centers.F);
                    const edgeB2 = findPiece(yellow, centers.B);
                    const edgeL2 = findPiece(yellow, centers.L);
                    const edgeR2 = findPiece(yellow, centers.R);
                    if(edgeF2 && edgeF2.pos.z === 1) count++;
                    if(edgeB2 && edgeB2.pos.z === -1) count++;
                    if(edgeL2 && edgeL2.pos.x === -1) count++;
                    if(edgeR2 && edgeR2.pos.x === 1) count++;
                    if(count === 4) { isSolved = true; break; }

                    await doMoves("R U R' U R U2 R'");
                }

                console.log("Solution found:", this.solutionMoves.join(' '));
                return this.solutionMoves;
            }
        }


        // --- SCRAMBLE, RESET, SOLVE ---
        function resetCube() {
            if (isAnimating) return;
            scene.remove(cubeGroup);
            createCube();
        }

        async function scrambleCube() {
            if (isAnimating) return;
            isAnimating = true;
            const moves = ["R", "L", "U", "D", "F", "B", "R'", "L'", "U'", "D'", "F'", "B'", "R2", "L2", "U2", "D2", "F2", "B2"];
            const scrambleLength = 25;
            const scramble = [];
            for (let i = 0; i < scrambleLength; i++) {
                const randomMove = moves[Math.floor(Math.random() * moves.length)];
                scramble.push(randomMove);
            }
            
            console.log("Scrambling with moves:", scramble.join(' '));
            for (const move of scramble) {
                await performMove(move);
            }
            isAnimating = false;
        }

        async function solveCube() {
            if (isAnimating) {
                console.log("Already solving.");
                return;
            }
            isAnimating = true;
            updateStatus('Starting solver...');

            try {
                const solver = new CubeSolver(performMove, getCubeState, updateStatus);
                console.log("Starting solver...");
                const solutionMoves = await solver.solve();
                console.log("Solution complete.");

                if (!solutionMoves || solutionMoves.length === 0) {
                     console.log("Cube is already solved or solver could not find a solution.");
                     updateStatus('Cube is already solved or no solution found');
                } else {
                    updateStatus('Replaying solution...');
                    for (const move of solutionMoves) {
                        await performMove(move);
                        await new Promise(res => setTimeout(res, 50));
                    }
                    updateStatus('Solved');
                }
            } catch (err) {
                console.error("Solver error:", err);
                updateStatus('Error: ' + err.message);
            } finally {
                isAnimating = false;
            }
        }

        // --- RENDER & RESIZE ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        function handleResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', handleResize);
        window.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
