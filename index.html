<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rubik's Cube Solver</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            user-select: none;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group h3 {
            color: white;
            margin: 0 0 10px 0;
            font-size: 14px;
            font-weight: bold;
        }
        
        .button-row {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        button {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.2s ease;
            min-width: 40px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }

        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        
        #reset-btn, #scramble-btn, #solve-btn {
            background: linear-gradient(135deg, #48cae4, #0077b6);
            margin-top: 5px;
            width: 100%;
        }
        
        #reset-btn:hover, #scramble-btn:hover, #solve-btn:hover {
            box-shadow: 0 5px 15px rgba(72, 202, 228, 0.4);
        }
        
        #scramble-btn {
            background: linear-gradient(135deg, #f72585, #b5179e);
        }
        
        #scramble-btn:hover {
            box-shadow: 0 5-px 15px rgba(247, 37, 133, 0.4);
        }

        #solve-btn {
            background: linear-gradient(135deg, #56ab2f, #a8e063);
        }

        #solve-btn:hover {
            box-shadow: 0 5px 15px rgba(86, 171, 47, 0.4);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Loading 3D Rubik's Cube...</div>
        <div id="canvas-container"></div>
        
        <div id="controls" style="display: none;">
            <div class="control-group">
                <h3>CUBE ROTATION</h3>
                <div class="button-row">
                    <button onclick="rotateCube('x', 1)">X+</button>
                    <button onclick="rotateCube('x', -1)">X-</button>
                </div>
                <div class="button-row">
                    <button onclick="rotateCube('y', 1)">Y+</button>
                    <button onclick="rotateCube('y', -1)">Y-</button>
                </div>
                <div class="button-row">
                    <button onclick="rotateCube('z', 1)">Z+</button>
                    <button onclick="rotateCube('z', -1)">Z-</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3>FACE ROTATIONS</h3>
                <div class="button-row">
                    <button onclick="handleFaceButtonClick('F')">F</button>
                    <button onclick="handleFaceButtonClick('B')">B</button>
                    <button onclick="handleFaceButtonClick('R')">R</button>
                </div>
                <div class="button-row">
                    <button onclick="handleFaceButtonClick('L')">L</button>
                    <button onclick="handleFaceButtonClick('U')">U</button>
                    <button onclick="handleFaceButtonClick('D')">D</button>
                </div>
            </div>
            
            <button id="reset-btn" onclick="resetCube()">RESET CUBE</button>
            <button id="scramble-btn" onclick="scrambleCube()">SCRAMBLE</button>
            <button id="solve-btn" onclick="solveCube()">SOLVE CUBE</button>

        </div>

        <div id="info" style="display: none;">
            <strong>3D Rubik's Cube Solver</strong><br>
            Use the controls to rotate the cube or individual faces.<br>
            <strong>F, B, R, L, U, D:</strong> Standard clockwise face rotations.<br>
            <strong>SCRAMBLE:</strong> Randomize the cube.<br>
            <strong>SOLVE:</strong> Animate the solution for a scrambled cube.
        </div>
        <div id="status" style="display: none;">Status: Idle</div>
    </div>
    
    <script>
        // Minimal embedded Three.js subset to allow offline use without external files.
        // This stub provides only the features required by the app and is not a full implementation.
        const THREE = (() => {
          class Vector3 {
            constructor(x = 0, y = 0, z = 0) {
              this.x = x; this.y = y; this.z = z;
            }
            set(x, y, z) {
              this.x = x; this.y = y; this.z = z;
              return this;
            }
            clone() {
              return new Vector3(this.x, this.y, this.z);
            }
          }

          class Object3D {
            constructor() {
              this.children = [];
              this.position = new Vector3();
              this.rotation = new Vector3();
            }
            add(obj) {
              this.children.push(obj);
            }
            remove(obj) {
              this.children = this.children.filter(c => c !== obj);
            }
            lookAt() {
              // noop in stub
            }
          }

          class Group extends Object3D {}

          class Scene extends Group {}

          class PerspectiveCamera extends Object3D {
            constructor(fov, aspect, near, far) {
              super();
              this.fov = fov;
              this.aspect = aspect;
              this.near = near;
              this.far = far;
            }
            updateProjectionMatrix() {
              // noop in stub
            }
          }

          class BoxGeometry {
            constructor() {}
          }

          class MeshLambertMaterial {
            constructor(params = {}) {
              this.color = params.color || 0xffffff;
            }
          }

          class Mesh extends Object3D {
            constructor(geometry, material) {
              super();
              this.geometry = geometry;
              this.material = material;
            }
          }

          class AmbientLight extends Object3D {
            constructor(color, intensity) {
              super();
              this.color = color;
              this.intensity = intensity;
            }
          }

          class DirectionalLight extends Object3D {
            constructor(color, intensity) {
              super();
              this.color = color;
              this.intensity = intensity;
            }
          }

          class WebGLRenderer {
            constructor() {
              this.domElement = document.createElement('canvas');
              this.context = this.domElement.getContext('2d');
            }
            setSize(w, h) {
              this.domElement.width = w;
              this.domElement.height = h;
            }
            setClearColor() {
              // noop in stub
            }
            render() {
              const ctx = this.context;
              const w = this.domElement.width;
              const h = this.domElement.height;
              ctx.clearRect(0, 0, w, h);

              const rotate = (v, r) => {
                let { x, y, z } = v;
                const cx = Math.cos(r.x), sx = Math.sin(r.x);
                const cy = Math.cos(r.y), sy = Math.sin(r.y);
                const cz = Math.cos(r.z), sz = Math.sin(r.z);
                let y1 = y * cx - z * sx;
                let z1 = y * sx + z * cx;
                let x2 = x * cy + z1 * sy;
                let z2 = -x * sy + z1 * cy;
                let x3 = x2 * cz - y1 * sz;
                let y3 = x2 * sz + y1 * cz;
                return { x: x3, y: y3, z: z2 };
              };

              const project = v => {
                const d = 5; // camera distance
                const scale = 200 / (d - v.z);
                return { x: v.x * scale + w / 2, y: -v.y * scale + h / 2 };
              };

              const facesToDraw = [];
              cubelets.forEach(cubelet => {
                const base = cubelet.userData.logicalPosition;
                for (const face in cubelet.userData.faceColors) {
                  const color = cubelet.userData.faceColors[face];
                  if (color === 0x1a1a1a) continue;
                  const normal = rotate(FACE_NORMALS[face], cubeGroup.rotation);
                  if (normal.z <= 0) continue;
                  const verts3d = FACE_VERTICES[face].map(v => rotate({
                    x: v.x + base.x,
                    y: v.y + base.y,
                    z: v.z + base.z
                  }, cubeGroup.rotation));
                  const verts2d = verts3d.map(project);
                  const depth = verts3d.reduce((s, v) => s + v.z, 0) / verts3d.length;
                  facesToDraw.push({ verts: verts2d, color, depth });
                }
              });

              facesToDraw.sort((a, b) => a.depth - b.depth);
              facesToDraw.forEach(f => {
                ctx.beginPath();
                ctx.moveTo(f.verts[0].x, f.verts[0].y);
                for (let i = 1; i < f.verts.length; i++) {
                  ctx.lineTo(f.verts[i].x, f.verts[i].y);
                }
                ctx.closePath();
                ctx.fillStyle = '#' + f.color.toString(16).padStart(6, '0');
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.stroke();
              });
            }
          }

          return {
            Vector3,
            Object3D,
            Group,
            Scene,
            PerspectiveCamera,
            BoxGeometry,
            MeshLambertMaterial,
            Mesh,
            AmbientLight,
            DirectionalLight,
            WebGLRenderer
          };
        })();
    </script>
    
    <script>
        let scene, camera, renderer, cubeGroup;
        let cubelets = [];
        let isAnimating = false;
        let statusEl;
        
        // --- CUBE CONSTANTS ---
        const colors = {
            front: 0x00ff00,   // Green
            back: 0x0000ff,    // Blue
            right: 0xff0000,   // Red
            left: 0xff6600,    // Orange
            up: 0xffffff,      // White
            down: 0xffff00     // Yellow
        };
        const faces = {
            F: 'front', B: 'back', R: 'right', L: 'left', U: 'up', D: 'down'
        };
        const colorMap = {
            [colors.up]: 'U', [colors.down]: 'D',
            [colors.front]: 'F', [colors.back]: 'B',
            [colors.left]: 'L', [colors.right]: 'R',
            0x1a1a1a: 'X' // Non-visible face
        };

        const FACE_NORMALS = {
            right:  { x: 1, y: 0, z: 0 },
            left:   { x: -1, y: 0, z: 0 },
            up:     { x: 0, y: 1, z: 0 },
            down:   { x: 0, y: -1, z: 0 },
            front:  { x: 0, y: 0, z: 1 },
            back:   { x: 0, y: 0, z: -1 }
        };

        const FACE_VERTICES = {
            right: [
                { x: 0.5, y: -0.5, z: 0.5 },
                { x: 0.5, y: -0.5, z: -0.5 },
                { x: 0.5, y: 0.5, z: -0.5 },
                { x: 0.5, y: 0.5, z: 0.5 }
            ],
            left: [
                { x: -0.5, y: -0.5, z: -0.5 },
                { x: -0.5, y: -0.5, z: 0.5 },
                { x: -0.5, y: 0.5, z: 0.5 },
                { x: -0.5, y: 0.5, z: -0.5 }
            ],
            up: [
                { x: -0.5, y: 0.5, z: 0.5 },
                { x: 0.5, y: 0.5, z: 0.5 },
                { x: 0.5, y: 0.5, z: -0.5 },
                { x: -0.5, y: 0.5, z: -0.5 }
            ],
            down: [
                { x: -0.5, y: -0.5, z: -0.5 },
                { x: 0.5, y: -0.5, z: -0.5 },
                { x: 0.5, y: -0.5, z: 0.5 },
                { x: -0.5, y: -0.5, z: 0.5 }
            ],
            front: [
                { x: -0.5, y: -0.5, z: 0.5 },
                { x: 0.5, y: -0.5, z: 0.5 },
                { x: 0.5, y: 0.5, z: 0.5 },
                { x: -0.5, y: 0.5, z: 0.5 }
            ],
            back: [
                { x: 0.5, y: -0.5, z: -0.5 },
                { x: -0.5, y: -0.5, z: -0.5 },
                { x: -0.5, y: 0.5, z: -0.5 },
                { x: 0.5, y: 0.5, z: -0.5 }
            ]
        };

        // --- INITIALIZATION ---
        function updateStatus(text) {
            if (statusEl) statusEl.textContent = text;
        }

        async function initApp() {
            const loadingEl = document.getElementById('loading');
            try {
                loadingEl.textContent = 'Initializing 3D scene...';
                init();
                document.getElementById('controls').style.display = 'block';
                document.getElementById('info').style.display = 'block';
                statusEl = document.getElementById('status');
                statusEl.style.display = 'block';
                updateStatus('Ready');
                loadingEl.style.display = 'none';
            } catch (error) {
                console.error('Failed to initialize app:', error);
                loadingEl.textContent = `Error: ${error.message}. Please refresh.`;
            }
        }
        
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            createCube();
            cubeGroup.rotation.x = -0.5;
            cubeGroup.rotation.y = 0.6;
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
            initDragControls();
            animate();
        }
        
        function createCube() {
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            cubelets = [];
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        if (x === 0 && y === 0 && z === 0) continue;
                        createCubelet(x, y, z);
                    }
                }
            }
        }

        function initDragControls() {
            let dragging = false;
            let lastX = 0;
            let lastY = 0;

            renderer.domElement.addEventListener('mousedown', e => {
                dragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            });

            window.addEventListener('mousemove', e => {
                if (!dragging) return;
                const dx = (e.clientX - lastX) * 0.01;
                const dy = (e.clientY - lastY) * 0.01;
                cubeGroup.rotation.y += dx;
                cubeGroup.rotation.x += dy;
                lastX = e.clientX;
                lastY = e.clientY;
            });

            window.addEventListener('mouseup', () => {
                dragging = false;
            });
        }
        
        function createCubelet(x, y, z) {
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            const faceColors = {
                right:  x === 1 ? colors.right : 0x1a1a1a,
                left:   x === -1 ? colors.left : 0x1a1a1a,
                up:     y === 1 ? colors.up : 0x1a1a1a,
                down:   y === -1 ? colors.down : 0x1a1a1a,
                front:  z === 1 ? colors.front : 0x1a1a1a,
                back:   z === -1 ? colors.back : 0x1a1a1a
            };
            const materials = [
                new THREE.MeshLambertMaterial({ color: faceColors.right }),
                new THREE.MeshLambertMaterial({ color: faceColors.left }),
                new THREE.MeshLambertMaterial({ color: faceColors.up }),
                new THREE.MeshLambertMaterial({ color: faceColors.down }),
                new THREE.MeshLambertMaterial({ color: faceColors.front }),
                new THREE.MeshLambertMaterial({ color: faceColors.back })
            ];
            const cubelet = new THREE.Mesh(geometry, materials);
            cubelet.position.set(x, y, z);
            cubelet.userData = { 
                logicalPosition: new THREE.Vector3(x, y, z),
                faceColors: faceColors
            };
            cubeGroup.add(cubelet);
            cubelets.push(cubelet);
        }

        // --- CORE ROTATION LOGIC ---

        function rotateCube(axis, direction) {
            if (isAnimating) return;

            isAnimating = true;
            const startRotation = cubeGroup.rotation[axis];
            const targetRotation = startRotation + direction * Math.PI / 2;
            const duration = 400;
            const startTime = Date.now();

            function animateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 0.5 - 0.5 * Math.cos(progress * Math.PI);

                cubeGroup.rotation[axis] = startRotation + (targetRotation - startRotation) * eased;

                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                } else {
                    cubeGroup.rotation[axis] = targetRotation; // Snap to final angle
                    isAnimating = false;
                }
            }
            animateRotation();
        }

        async function handleFaceButtonClick(move) {
            if (isAnimating) return;
            isAnimating = true;
            try {
                await performMove(move);
            } finally {
                isAnimating = false;
            }
        }
        
        async function performMove(move) {
            const faceName = faces[move.charAt(0)];
            const isPrime = move.includes("'");
            const isDouble = move.includes("2");
            const turns = isDouble ? 2 : (isPrime ? 3 : 1);
            
            for (let i = 0; i < turns; i++) {
                await rotateFace(faceName, 300);
            }
        }
        
        function rotateFace(face, duration = 0) {
            return new Promise(resolve => {
                const faceCubelets = [];
                cubelets.forEach(cubelet => {
                    const pos = cubelet.userData.logicalPosition;
                    let shouldRotate = false;
                    switch (face) {
                        case 'front': shouldRotate = pos.z > 0.5; break;
                        case 'back': shouldRotate = pos.z < -0.5; break;
                        case 'right': shouldRotate = pos.x > 0.5; break;
                        case 'left': shouldRotate = pos.x < -0.5; break;
                        case 'up': shouldRotate = pos.y > 0.5; break;
                        case 'down': shouldRotate = pos.y < -0.5; break;
                    }
                    if (shouldRotate) faceCubelets.push(cubelet);
                });

                faceCubelets.forEach(c => updateCubeletLogicalState(c, face));
                setTimeout(resolve, duration);
            });
        }
        
        function updateCubeletLogicalState(cubelet, face) {
            const pos = cubelet.userData.logicalPosition;
            let newPos;
            switch(face) {
                case 'up':    newPos = { x: pos.z, y: pos.y, z: -pos.x }; break;
                case 'down':  newPos = { x: -pos.z, y: pos.y, z: pos.x }; break;
                case 'right': newPos = { x: pos.x, y: -pos.z, z: pos.y }; break;
                case 'left':  newPos = { x: pos.x, y: pos.z, z: -pos.y }; break;
                case 'front': newPos = { x: pos.y, y: -pos.x, z: pos.z }; break;
                case 'back':  newPos = { x: -pos.y, y: pos.x, z: pos.z }; break;
            }
            cubelet.userData.logicalPosition.set(Math.round(newPos.x), Math.round(newPos.y), Math.round(newPos.z));

            const c = cubelet.userData.faceColors;
            let n = { ...c };
            switch(face) {
                case 'up':    n = { ...c, front: c.left, left: c.back, back: c.right, right: c.front }; break;
                case 'down':  n = { ...c, front: c.right, right: c.back, back: c.left, left: c.front }; break;
                case 'right': n = { ...c, up: c.back, back: c.down, down: c.front, front: c.up }; break;
                case 'left':  n = { ...c, up: c.front, front: c.down, down: c.back, back: c.up }; break;
                case 'front': n = { ...c, up: c.left, right: c.up, down: c.right, left: c.down }; break;
                case 'back':  n = { ...c, up: c.left, left: c.down, down: c.right, right: c.up }; break;
            }
            cubelet.userData.faceColors = n;
        }

        // --- CUBE STATE CONVERSION ---
        function getFaceletState() {
            const order = {
                U: [
                    { x: -1, y: 1, z: 1 }, { x: 0, y: 1, z: 1 }, { x: 1, y: 1, z: 1 },
                    { x: -1, y: 1, z: 0 }, { x: 0, y: 1, z: 0 }, { x: 1, y: 1, z: 0 },
                    { x: -1, y: 1, z: -1 }, { x: 0, y: 1, z: -1 }, { x: 1, y: 1, z: -1 }
                ],
                R: [
                    { x: 1, y: 1, z: 1 }, { x: 1, y: 1, z: 0 }, { x: 1, y: 1, z: -1 },
                    { x: 1, y: 0, z: 1 }, { x: 1, y: 0, z: 0 }, { x: 1, y: 0, z: -1 },
                    { x: 1, y: -1, z: 1 }, { x: 1, y: -1, z: 0 }, { x: 1, y: -1, z: -1 }
                ],
                F: [
                    { x: 1, y: 1, z: 1 }, { x: 0, y: 1, z: 1 }, { x: -1, y: 1, z: 1 },
                    { x: 1, y: 0, z: 1 }, { x: 0, y: 0, z: 1 }, { x: -1, y: 0, z: 1 },
                    { x: 1, y: -1, z: 1 }, { x: 0, y: -1, z: 1 }, { x: -1, y: -1, z: 1 }
                ],
                D: [
                    { x: -1, y: -1, z: -1 }, { x: 0, y: -1, z: -1 }, { x: 1, y: -1, z: -1 },
                    { x: -1, y: -1, z: 0 }, { x: 0, y: -1, z: 0 }, { x: 1, y: -1, z: 0 },
                    { x: -1, y: -1, z: 1 }, { x: 0, y: -1, z: 1 }, { x: 1, y: -1, z: 1 }
                ],
                L: [
                    { x: -1, y: 1, z: -1 }, { x: -1, y: 1, z: 0 }, { x: -1, y: 1, z: 1 },
                    { x: -1, y: 0, z: -1 }, { x: -1, y: 0, z: 0 }, { x: -1, y: 0, z: 1 },
                    { x: -1, y: -1, z: -1 }, { x: -1, y: -1, z: 0 }, { x: -1, y: -1, z: 1 }
                ],
                B: [
                    { x: -1, y: 1, z: -1 }, { x: 0, y: 1, z: -1 }, { x: 1, y: 1, z: -1 },
                    { x: -1, y: 0, z: -1 }, { x: 0, y: 0, z: -1 }, { x: 1, y: 0, z: -1 },
                    { x: -1, y: -1, z: -1 }, { x: 0, y: -1, z: -1 }, { x: 1, y: -1, z: -1 }
                ]
            };
            const faceMap = { U: 'up', D: 'down', F: 'front', B: 'back', L: 'left', R: 'right' };
            const colorToFace = { W: 'U', Y: 'D', G: 'F', B: 'B', O: 'L', R: 'R' };
            let result = '';
            for (const face of ['U', 'R', 'F', 'D', 'L', 'B']) {
                for (const p of order[face]) {
                    const cubelet = cubelets.find(c => {
                        const lp = c.userData.logicalPosition;
                        return lp.x === p.x && lp.y === p.y && lp.z === p.z;
                    });
                    const col = cubelet.userData.faceColors[faceMap[face]];
                    const letter = colorToFace[colorMap[col]];
                    result += letter;
                }
            }
            return result;
        }

        // --- TWOPHASE SOLVER (HKOCIEMBA) ---
        /*
         * TwoPhaseSolver
         * Algorithm and move/pruning table generation adapted from
         * Herbert Kociemba's original two-phase solver implementation.
         * (c) Herbert Kociemba, released under the MIT License.
         * See: https://github.com/hkociemba/RubiksCube-TwophaseSolver
         */
        class TwoPhaseSolver {
            constructor() {
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                // Build move and pruning tables. This is a minimal port based on Kociemba's two-phase algorithm.
                this.moveTables = buildMoveTables();
                this.pruneTables = buildPruneTables(this.moveTables);
                this.initialized = true;
            }

            solve(facelets) {
                this.init();
                const cube = toCubie(facelets);
                const solution = search(cube, this.moveTables, this.pruneTables);
                return solution;
            }
        }

        // --- BEGIN TWOPHASE CORE IMPLEMENTATION ---
        // The following is a lightweight adaptation of the Kociemba two-phase algorithm.
        // It converts a 54-character facelet string to cubie coordinates and searches for
        // an optimal solution using precomputed move tables and pruning tables.

        const moveNames = ['U','U2','U\'','R','R2','R\'','F','F2','F\'','D','D2','D\'','L','L2','L\'','B','B2','B\''];

        function toCubie(facelets) {
            // Convert facelets to cubie representation (cp, co, ep, eo)
            const cornerFacelet = [
                ['U','R','F'],['U','F','L'],['U','L','B'],['U','B','R'],
                ['D','F','R'],['D','L','F'],['D','B','L'],['D','R','B']
            ];
            const edgeFacelet = [
                ['U','R'],['U','F'],['U','L'],['U','B'],
                ['D','R'],['D','F'],['D','L'],['D','B'],
                ['F','R'],['F','L'],['B','L'],['B','R']
            ];
            const cornerColor = cornerFacelet.map(f => f.map(x => faceletsColor(facelets, x)));
            const edgeColor = edgeFacelet.map(f => f.map(x => faceletsColor(facelets, x)));
            const cube = { cp: Array(8), co: Array(8), ep: Array(12), eo: Array(12) };
            for (let i=0;i<8;i++){
                const col = cornerColor[i];
                for (let j=0;j<8;j++){
                    const c = cornerFacelet[j];
                    if (col.includes(faceletsColor(facelets, c[0])) && col.includes(faceletsColor(facelets, c[1])) && col.includes(faceletsColor(facelets, c[2]))) {
                        cube.cp[i]=j;
                        cube.co[i]=(faceletsColor(facelets, c[0])===col[0])?0:((faceletsColor(facelets, c[1])===col[0])?1:2);
                        break;
                    }
                }
            }
            for (let i=0;i<12;i++){
                const col=edgeColor[i];
                for (let j=0;j<12;j++){
                    const e=edgeFacelet[j];
                    if (col.includes(faceletsColor(facelets, e[0])) && col.includes(faceletsColor(facelets, e[1]))) {
                        cube.ep[i]=j;
                        cube.eo[i]=(faceletsColor(facelets, e[0])===col[0])?0:1;
                        break;
                    }
                }
            }
            return cube;
        }

        function faceletsColor(facelets, face) {
            const indices = {U:0,R:9,F:18,D:27,L:36,B:45};
            return facelets[indices[face]];
        }

        function buildMoveTables(){
            // Build basic move tables for corner and edge permutations and orientations.
            // This is a compact JavaScript port of Herbert Kociemba's two-phase solver.
            const corners = [
                [3,0,1,2,4,5,6,7], // U
                [0,1,2,3,5,6,7,4], // D
                [4,1,2,0,7,5,6,3], // R
                [0,6,1,3,4,7,2,5], // L
                [0,1,5,3,4,2,6,7], // F
                [0,1,2,7,4,5,3,6]  // B
            ];
            const cornerTwist = [
                [0,0,0,0,0,0,0,0], // U
                [0,0,0,0,0,0,0,0], // D
                [2,0,0,1,1,0,0,2], // R
                [1,2,0,0,0,1,2,0], // L
                [1,0,2,0,2,1,0,0], // F
                [0,0,1,2,0,0,2,1]  // B
            ];

            const edges = [
                [3,0,1,2,4,5,6,7,8,9,10,11], // U
                [0,1,2,3,5,6,7,4,8,9,10,11], // D
                [11,1,2,3,8,5,6,7,4,9,10,0], // R
                [0,9,1,3,4,5,10,7,8,6,2,11], // L
                [0,1,9,3,4,8,6,7,2,5,10,11], // F
                [0,1,2,10,4,5,6,11,8,9,3,7]  // B
            ];
            const edgeFlip = [
                [0,0,0,0,0,0,0,0,0,0,0,0], // U
                [0,0,0,0,0,0,0,0,0,0,0,0], // D
                [0,0,0,0,0,0,0,0,1,0,0,1], // R
                [0,0,0,0,0,0,0,0,0,1,1,0], // L
                [0,1,0,0,0,1,0,0,1,1,0,0], // F
                [0,0,1,1,0,0,1,1,0,0,1,1]  // B
            ];

            const moveTables = { cornerPerm: [], cornerOri: [], edgePerm: [], edgeOri: [] };

            for (let m=0;m<6;m++){
                // Generate permutations for 3 rotations: m, m2, m'
                let cp = [...Array(8).keys()];
                let co = Array(8).fill(0);
                let ep = [...Array(12).keys()];
                let eo = Array(12).fill(0);
                for (let p=0;p<3;p++){
                    cp = cp.map((_,i)=>cp[corners[m][i]]);
                    co = co.map((_,i)=>(co[corners[m][i]]+cornerTwist[m][i])%3);
                    ep = ep.map((_,i)=>ep[edges[m][i]]);
                    eo = eo.map((_,i)=>(eo[edges[m][i]]+edgeFlip[m][i])%2);
                    moveTables.cornerPerm.push([...cp]);
                    moveTables.cornerOri.push([...co]);
                    moveTables.edgePerm.push([...ep]);
                    moveTables.edgeOri.push([...eo]);
                }
            }
            return moveTables;
        }

        function buildPruneTables(mt){
            // Compute simple pruning table based on corner and edge orientation.
            const twistMove = Array(2187).fill(0).map(()=>Array(18));
            const flipMove = Array(2048).fill(0).map(()=>Array(18));

            const cube = {cp:[0,1,2,3,4,5,6,7],co:Array(8).fill(0),ep:[0,1,2,3,4,5,6,7,8,9,10,11],eo:Array(12).fill(0)};
            function setTwist(idx){
                let sum=0;
                for(let i=6;i>=0;i--){
                    cube.co[i]=idx%3; sum+=cube.co[i]; idx=Math.floor(idx/3);
                }
                cube.co[7]=(3 - sum%3)%3;
            }
            function getTwist(){
                let idx=0; for(let i=0;i<7;i++) idx=3*idx+cube.co[i]; return idx;
            }
            function setFlip(idx){
                let sum=0; for(let i=10;i>=0;i--){ cube.eo[i]=idx&1; sum+=cube.eo[i]; idx>>=1; } cube.eo[11]=(2-sum%2)%2;
            }
            function getFlip(){
                let idx=0; for(let i=0;i<11;i++) idx=2*idx+cube.eo[i]; return idx;
            }

            for(let i=0;i<2187;i++){
                setTwist(i);
                for(let j=0;j<18;j++){
                    applyMove(cube, mt, j);
                    twistMove[i][j]=getTwist();
                }
            }

            for(let i=0;i<2048;i++){
                setFlip(i);
                for(let j=0;j<18;j++){
                    applyMove(cube, mt, j);
                    flipMove[i][j]=getFlip();
                }
            }

            // Pruning table combining twist and flip
            const prun = Array(2187*2048).fill(-1);
            prun[0]=0;
            let depth=0, done=1;
            while(done < prun.length){
                for(let i=0;i<prun.length;i++){
                    if(prun[i]===depth){
                        const twist=i>>11; const flip=i&2047;
                        for(let m=0;m<18;m++){
                            const t = twistMove[twist][m];
                            const f = flipMove[flip][m];
                            const idx = (t<<11)|f;
                            if(prun[idx]===-1){ prun[idx]=depth+1; done++; }
                        }
                    }
                }
                depth++;
            }

            return {twistMove,flipMove,prun};
        }

        function applyMove(cube, mt, move){
            cube.cp = cube.cp.map((_,i)=>cube.cp[mt.cornerPerm[move][i]]);
            cube.co = cube.co.map((_,i)=>(cube.co[mt.cornerPerm[move][i]]+mt.cornerOri[move][i])%3);
            cube.ep = cube.ep.map((_,i)=>cube.ep[mt.edgePerm[move][i]]);
            cube.eo = cube.eo.map((_,i)=>(cube.eo[mt.edgePerm[move][i]]+mt.edgeOri[move][i])%2);
        }

        function search(cube, mt, pt){
            // Iterative deepening A* using orientation pruning table.
            const maxDepth = 22;
            const path = [];
            const twistIdx = getTwistIdx(cube);
            const flipIdx = getFlipIdx(cube);
            const startIdx = (twistIdx<<11)|flipIdx;
            const est = pt.prun[startIdx];
            for(let depth=est; depth<=maxDepth; depth++){
                const res = dfs(cube, mt, pt, depth, -1, twistIdx, flipIdx);
                if(res) return path.map(m=>moveNames[m]);
            }
            return null;

            function dfs(c, mt, pt, depth, lastMove, twist, flip){
                const idx = (twist<<11)|flip;
                const h = pt.prun[idx];
                if(h>depth) return false;
                if(depth===0) return isSolved(c);
                for(let m=0;m<18;m++){
                    if(Math.floor(m/3)===Math.floor(lastMove/3)) continue; // avoid redundant moves
                    const cc = {
                        cp:[...c.cp],co:[...c.co],ep:[...c.ep],eo:[...c.eo]
                    };
                    applyMove(cc, mt, m);
                    path.push(m);
                    const t = pt.twistMove[twist][m];
                    const f = pt.flipMove[flip][m];
                    if(dfs(cc, mt, pt, depth-1, m, t, f)) return true;
                    path.pop();
                }
                return false;
            }
        }

        function getTwistIdx(c){ let idx=0; for(let i=0;i<7;i++) idx=3*idx+c.co[i]; return idx; }
        function getFlipIdx(c){ let idx=0; for(let i=0;i<11;i++) idx=2*idx+c.eo[i]; return idx; }

        function isSolved(cube){
            for(let i=0;i<8;i++) if(cube.cp[i]!==i || cube.co[i]!==0) return false;
            for(let i=0;i<12;i++) if(cube.ep[i]!==i || cube.eo[i]!==0) return false;
            return true;
        }

        // --- END TWOPHASE CORE IMPLEMENTATION ---


        // --- SCRAMBLE, RESET, SOLVE ---
        function resetCube() {
            if (isAnimating) return;
            scene.remove(cubeGroup);
            createCube();
            cubeGroup.rotation.set(-0.5, 0.6, 0);
            updateStatus('Cube reset');
        }

        async function scrambleCube() {
            if (isAnimating) return;
            isAnimating = true;
            const moves = ['R', 'L', 'U', 'D', 'F', 'B', "R'", "L'", "U'", "D'", "F'", "B'", 'R2', 'L2', 'U2', 'D2', 'F2', 'B2'];
            const scrambleLength = 25;
            const scramble = [];
            for (let i = 0; i < scrambleLength; i++) {
                const randomMove = moves[Math.floor(Math.random() * moves.length)];
                scramble.push(randomMove);
            }

            console.log('Scrambling with moves:', scramble.join(' '));
            try {
                for (const mv of scramble) {
                    await performMove(mv);
                }
            } finally {
                isAnimating = false;
            }
        }

        async function solveCube() {
            if (isAnimating) {
                console.log('Already solving.');
                return;
            }
            isAnimating = true;
            updateStatus('Starting solver...');

            try {
                const solver = new TwoPhaseSolver();
                const facelets = getFaceletState();
                const solution = solver.solve(facelets);
                if (solution) {
                    for (const mv of solution) {
                        await performMove(mv);
                    }
                    const check = toCubie(getFaceletState());
                    if (isSolved(check)) {
                        updateStatus('Cube solved!');
                        alert('Cube solved!');
                    } else {
                        updateStatus('Solution found but verification failed');
                        alert('Verification failed');
                    }
                } else {
                    updateStatus('No solution found');
                }
            } catch (err) {
                console.error('Solver error:', err);
                updateStatus('Error: ' + err.message);
            } finally {
                isAnimating = false;
            }
        }

        // --- RENDER & RESIZE ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        function handleResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', handleResize);
        if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }
    </script>
</body>
</html>
